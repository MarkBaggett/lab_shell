#!/usr/bin/env bash
# Global Declarations
ARG="$1"
ARGC=$#
CONFIG=/etc/islet/islet.conf
COUNT=0
LIST=()
ANIMATE=$(which pv 2>/dev/null)
ANIMATE_SPEED=90
TIMEOUT="8h"

# Store some stuff, these can be referenced from config files
read CLIENT SRCPORT SERVER DSTPORT <<<"${SSH_CONNECTION}"
export CLIENT SRCPORT SERVER DSTPORT IP="$SERVER"
export SSH_TTY
export DISPLAY="${CLIENT}:0"
export TERM
export PPID HOST_PORT="$PPID"
export TMOUT=60
export CONFIG
export USER
readonly CLIENT SRCPORT SERVER DSTPORT SSH_TTY TERM PPID TMOUT

err(){
  local message="$1"
  logger -s -p local0.notice -t "islet" "$0: $message"
  exit 1
}

# Get global variables
if [[ -f "$CONFIG" ]]; then
  . "$CONFIG"
  . "$LIBISLET"
  readonly CONFIG
else
  err "Error: ${CONFIG:-config} or ${LIBISLET:-libislet} not found!"
fi

# Export import_configs function to use in modules
export -f import_configs

# Rewrite MODULE variable for ease of use
MODULE="$INSTALL_DIR/modules/$MODULE"

clear

readonly TIME=$(date +"%s")
readonly EXPIRATION=$(date --date=@$((TIME+86400*DAYS)) +"%c")

# Display ISLET Banner
if [[ "$ARG" != "nobanner" ]]; then
  test -f "${ANIMATE:-notset}" && islet_banner | pv -qL "$ANIMATE_SPEED" || islet_banner
  # Press key to continue
  timecount $TMOUT
  clear && echo
fi

#######################################
# Create SQLite database
# Globals:
#   DB   - Location of database file
#   USER - Owner of database file
#   GROUP - Group of database file
# Arguments:
#   None
# Returns:
#   None
#######################################

create_db() {
sqlite3 "$DB" <<EOF
PRAGMA foreign_keys = ON;
CREATE TABLE accounts (
        user VARCHAR PRIMARY KEY,
        ts TIMESTAMP
);
CREATE TABLE environments (
        user VARCHAR REFERENCES accounts(user) ON DELETE CASCADE,
        environment VARCHAR
);
CREATE UNIQUE INDEX idx_environments_user_environment ON environments(user, environment);
EOF
return 0
}

is_sqlite() {
  local file="$(which sqlite3)"
  [[ -f "$file" ]] || quit "Fatal: sqlite3 not found, is it installed and in the PATH?"
  if ! file "$DB" 2>/dev/null | grep -q SQLite; then
    rm -f "$DB" 2>/dev/null
    create_db
    test $? -eq 0 && return 0 || quit "Unable to create $DB"
  fi
}

###################################################
# Handles db entires for container reattachment
# Globals:
#   None
# Arguments:
#   None
# Returns:
#   None
###################################################

identify(){
  auth=$(sqlite3 $DB "SELECT user FROM accounts WHERE user='$USER';")
  if [[ "$auth" ]]
  then
  	log "${USER}: Account already exists"
  else
  	sqlite3 "$DB" "pragma foreign_keys = on; INSERT INTO accounts VALUES('"${USER}"', strftime('%s', 'now'));" 2>/dev/null || quit "Couldn't write to $DB!"
  	log "${USER}: Account created from $CLIENT"
  fi
}

menu_loop(){
  while true; do
    { [[ -d "$CONFIG_DIR" ]] && cd "$CONFIG_DIR"; } || quit "Unable to access ${CONFIG_DIR}!"
    LIST=()
    config_menu
  done
}

config_menu(){
  local count=0
  local menu
  local attach
  # Configuration menu
  notice "\t\t\t\tAvailable configurations:\n"
  printf '\t\t\t%-29s %-7s %-30s\n' "${B}Configuration${N}" "|" "${B}Description${N}"
  printf '\t\t\t%-30s %-7s %-30s\n' "${BF}$SPACER1${N}" "|" "${BF}$SPACER1${N}"

  # Iterate over configuration files in $CONFIG_DIR and display them as options
  # It prints the config file ($config) and its description ($DESCRIPTION)
  unset BANNER VISIBLE ENABLE PLUGIN config config_name
  for config in environments/*.conf plugins/*.conf; do
    [[ -f "$config" ]] && . "$config"
    if [[ "$VISIBLE" = "yes" || "$ENABLE" = "yes" ]]; then
      config_name="$(basename $config)" # blah.conf
      printf '\t\t\t%-30s %-7s %-30s\n' "${WF}$config_name${N}" "|" "${U}$DESCRIPTION${N}"
      LIST+=("$config")
    fi
    unset BANNER VISIBLE ENABLE PLUGIN config config_name
  done

  # Quit if there are no config files present
  [[ "${#LIST[@]}" -eq 0 ]] && quit "\t\t\tNo configurations available!"
  echo && unset BANNER
  notice "Choose a number to load the configuration (or ^C to exit):"

  PS3="${Y}[${N}${BF}Choice${N}${Y}]${N}: "
  # Here the user chooses the configuration from the menu
  # Inherit the variables from the config file after selection
  select CONFIGURATION in "${LIST[@]}"
  do
    menu=1
    if [[ -f "$CONFIG_DIR/$CONFIGURATION" ]]; then
      . "$CONFIG_DIR/$CONFIGURATION" # /etc/islet + / + environments/blah.conf
      # Export for use in modules
      BASE=$(basename $(basename $CONFIGURATION) .conf)
      export CONFIGURATION  # environments/blah.conf
      export BASE           # blah
      break
    else
      let count++
      if [[ "$count" -ge "$FAILURE_COUNT" ]]; then
        quit "Too many failed attempts! ($count/$FAILURE_COUNT)"
      fi
      alert "Invalid choice! Try again ($count/$FAILURE_COUNT)"
    fi
  done

  unset LIST

  # If configuration is for plugin then execute it
  if [[ $PLUGIN ]]; then
    if [[ -f "$INSTALL_DIR/plugins/$PLUGIN" ]]; then
      . "$INSTALL_DIR/plugins/$PLUGIN"
    else
      alert "Plugin $PLUGIN does not exist..contact the administrator."
    fi
    # Go back to menu_loop after
    unset PLUGIN
    return 0
  fi

  # Avoid launching last value of CONFIGURATION when user sends EOF
  [[ $menu ]] || quit "Quit by user..."
  unset menu

  # Display environment banner
  [[ "$BANNER" ]] && clear && echo "$BANNER"

  # This is how we handle using the same account for multiple environments
  attach=$(sqlite3 $DB "SELECT environment FROM environments WHERE user='$USER' AND environment='$BASE'";)
  if [[ $attach ]]; then
    $MODULE attach # Call function in module to attach to existing environment
  else
    $MODULE start  # Call function in module to create environment
  fi
}

trap 'echo; quit "Trap received, exiting..."' 1 2 3 20
# It all begins here
is_sqlite
$MODULE verify
identify
menu_loop
exit